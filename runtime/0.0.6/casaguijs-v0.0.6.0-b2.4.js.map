{"version":3,"sources":["@@/dist/lib/index.js","@@/dist/lib/src/bokeh/sources/data_pipe.js","@@/dist/lib/src/bokeh/sources/image_pipe.js","@@/dist/lib/src/bokeh/sources/image_data_source.js","@@/dist/lib/src/bokeh/sources/spectra_data_source.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* index.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const data_pipe_1 = require(\"989790dae8\") /* ./src/bokeh/sources/data_pipe */;\n    __esExport(\"DataPipe\", data_pipe_1.DataPipe);\n    const image_pipe_1 = require(\"86e287dc15\") /* ./src/bokeh/sources/image_pipe */;\n    __esExport(\"ImagePipe\", image_pipe_1.ImagePipe);\n    const image_data_source_1 = require(\"20c0382ad2\") /* ./src/bokeh/sources/image_data_source */;\n    __esExport(\"ImageDataSource\", image_data_source_1.ImageDataSource);\n    const spectra_data_source_1 = require(\"e5ac72e4af\") /* ./src/bokeh/sources/spectra_data_source */;\n    __esExport(\"SpectraDataSource\", spectra_data_source_1.SpectraDataSource);\n    const base_1 = require(\"@bokehjs/base\");\n    (0, base_1.register_models)({ DataPipe: data_pipe_1.DataPipe, ImagePipe: image_pipe_1.ImagePipe, ImageDataSource: image_data_source_1.ImageDataSource, SpectraDataSource: spectra_data_source_1.SpectraDataSource });\n}\n","/* src/bokeh/sources/data_pipe.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const data_source_1 = require(\"@bokehjs/models/sources/data_source\");\n    const serialization_1 = require(\"@bokehjs/core/util/serialization\");\n    class DataPipe extends data_source_1.DataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.send_queue = {};\n            this.pending = {};\n            this.incoming_callbacks = {};\n            let ws_address = `ws://${this.address[0]}:${this.address[1]}`;\n            console.log(\"datapipe url:\", ws_address);\n            this.websocket = new WebSocket(ws_address);\n            this.websocket.binaryType = \"arraybuffer\";\n            this.websocket.onmessage = (event) => {\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                // helper function\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                function expand_arrays(obj) {\n                    const res = Array.isArray(obj) ? new Array() : {};\n                    for (const key in obj) {\n                        let value = obj[key];\n                        if ((0, serialization_1.is_NDArray_ref)(value)) {\n                            const buffers0 = new Map();\n                            res[key] = (0, serialization_1.decode_NDArray)(value, buffers0);\n                        }\n                        else {\n                            res[key] = typeof value === 'object' && value !== null ? expand_arrays(value) : value;\n                        }\n                    }\n                    return res;\n                }\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                if (typeof event.data === 'string' || event.data instanceof String) {\n                    let obj = JSON.parse(event.data);\n                    let data = expand_arrays(obj);\n                    if ('id' in data && 'direction' in data && 'message' in data) {\n                        let { id, message, direction } = data;\n                        if (direction == 'j2p') {\n                            if (id in this.pending) {\n                                let { cb } = this.pending[id];\n                                delete this.pending[id];\n                                if (id in this.send_queue && this.send_queue[id].length > 0) {\n                                    // send next message queued by 'id'\n                                    let { cb, msg } = this.send_queue[id].shift();\n                                    this.pending[id] = { cb };\n                                    this.websocket.send(JSON.stringify(msg));\n                                }\n                                // post message\n                                cb(message);\n                            }\n                            else {\n                                console.log(\"message received but could not find id\");\n                            }\n                        }\n                        else {\n                            if (id in this.incoming_callbacks) {\n                                let result = this.incoming_callbacks[id](message);\n                                this.websocket.send(JSON.stringify({ id, direction, message: result, session: object_id(this) }));\n                            }\n                        }\n                    }\n                    else {\n                        console.log(`datapipe received message without one of 'id', 'message' or 'direction': ${data}`);\n                    }\n                }\n                else {\n                    console.log(\"datapipe received binary data\", event.data.byteLength, \"bytes\");\n                }\n            };\n            let session = object_id(this);\n            this.websocket.onopen = () => {\n                this.websocket.send(JSON.stringify({ id: 'initialize', direction: 'j2p', session }));\n            };\n        }\n        initialize() {\n            super.initialize();\n            const execute = () => {\n                if (this.init_script != null)\n                    this.init_script.execute(this);\n            };\n            execute();\n        }\n        register(id, cb) {\n            this.incoming_callbacks[id] = cb;\n        }\n        send(id, message, cb) {\n            let msg = { id, message, direction: 'j2p', session: object_id(this) };\n            if (id in this.pending) {\n                if (id in this.send_queue) {\n                    this.send_queue[id].push({ cb, msg });\n                }\n                else {\n                    this.send_queue[id] = [{ cb, msg }];\n                }\n            }\n            else {\n                if (id in this.send_queue && this.send_queue[id].length > 0) {\n                    this.send_queue[id].push({ cb, msg });\n                    { // seemingly cannot reference wider 'cb' and the block-scoped\n                        // 'cb' within the same block...\n                        // src/bokeh/sources/data_pipe.ts:100:45 - error TS2448: Block-scoped variable 'cb' used before its declaration.\n                        let { cb, msg } = this.send_queue[id].shift();\n                        this.pending[id] = { cb };\n                        this.websocket.send(JSON.stringify(msg));\n                    }\n                }\n                else {\n                    this.pending[id] = { cb };\n                    this.websocket.send(JSON.stringify(msg));\n                }\n            }\n        }\n        static init_DataPipe() {\n            this.define(({ Tuple, String, Number, Any }) => ({\n                init_script: [Any],\n                address: [Tuple(String, Number)],\n            }));\n        }\n    }\n    exports.DataPipe = DataPipe;\n    DataPipe.__name__ = \"DataPipe\";\n    DataPipe.init_DataPipe();\n}\n","/* src/bokeh/sources/image_pipe.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const data_source_1 = require(\"@bokehjs/models/sources/data_source\");\n    const serialization_1 = require(\"@bokehjs/core/util/serialization\");\n    class ImagePipe extends data_source_1.DataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.queue = {};\n            this.pending = {};\n            this.position = {};\n            let ws_address = `ws://${this.address[0]}:${this.address[1]}`;\n            console.log(\"imagepipe url:\", ws_address);\n            this.websocket = new WebSocket(ws_address);\n            this.websocket.binaryType = \"arraybuffer\";\n            this.websocket.onmessage = (event) => {\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                // helper function\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                function expand_arrays(obj) {\n                    const res = Array.isArray(obj) ? new Array() : {};\n                    for (const key in obj) {\n                        let value = obj[key];\n                        if ((0, serialization_1.is_NDArray_ref)(value)) {\n                            const buffers0 = new Map();\n                            res[key] = (0, serialization_1.decode_NDArray)(value, buffers0);\n                        }\n                        else {\n                            res[key] = typeof value === 'object' && value !== null ? expand_arrays(value) : value;\n                        }\n                    }\n                    return res;\n                }\n                //--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n                if (typeof event.data === 'string' || event.data instanceof String) {\n                    let obj = JSON.parse(event.data);\n                    let data = expand_arrays(obj);\n                    if ('id' in data && 'message' in data) {\n                        // 'message' here is generated in python and\n                        // contains the requested slice of the image\n                        let { id, message } = data;\n                        let { cb, index } = this.pending[id];\n                        delete this.pending[id];\n                        if (id in this.queue) {\n                            // send next message queued by 'id'\n                            let { cb, message, index } = this.queue[id];\n                            delete this.queue[id];\n                            this.pending[id] = { cb, index };\n                            this.websocket.send(JSON.stringify(message));\n                        }\n                        // post message\n                        this.position[id] = { index };\n                        cb(message);\n                    }\n                    else {\n                        console.log(`imagepipe received data without 'id' and/or 'message' field: ${data}`);\n                    }\n                }\n                else {\n                    console.log(\"imagepipe received binary data\", event.data.byteLength, \"bytes\");\n                }\n            };\n            let session = object_id(this);\n            this.websocket.onopen = () => {\n                this.websocket.send(JSON.stringify({ action: 'initialize', session }));\n            };\n        }\n        initialize() {\n            super.initialize();\n            const execute = () => {\n                if (this.init_script != null)\n                    this.init_script.execute(this);\n            };\n            execute();\n        }\n        // fetch channel\n        //    index: [ stokes index, spectral plane ]\n        // RETURNED MESSAGE SHOULD HAVE { id: string, message: any }\n        channel(index, cb, id) {\n            let message = { action: 'channel', index, id, session: object_id(this) };\n            if (id in this.pending) {\n                this.queue[id] = { cb, message, index };\n            }\n            else {\n                this.websocket.send(JSON.stringify(message));\n                this.pending[id] = { cb, index };\n            }\n        }\n        // fetch spectra\n        //    index: [ RA index, DEC index, stokes index ]\n        // RETURNED MESSAGE SHOULD HAVE { id: string, message: any }\n        spectra(index, cb, id) {\n            let message = { action: 'spectra', index, id, session: object_id(this) };\n            if (id in this.pending) {\n                this.queue[id] = { cb, message, index };\n            }\n            else {\n                this.websocket.send(JSON.stringify(message));\n                this.pending[id] = { cb, index };\n            }\n        }\n        refresh(cb, id, default_index = []) {\n            let { index } = id in this.position ? this.position[id] : { index: default_index };\n            if (index.length === 2) {\n                // refreshing channel\n                let message = { action: 'channel', index, id, session: object_id(this) };\n                if (id in this.pending) {\n                    this.queue[id] = { cb, message, index };\n                }\n                else {\n                    this.websocket.send(JSON.stringify(message));\n                    this.pending[id] = { cb, index };\n                }\n            }\n            else if (index.length === 3) {\n                // refreshing spectra\n                let message = { action: 'spectra', index, id, session: object_id(this) };\n                if (id in this.pending) {\n                    this.queue[id] = { cb, message, index };\n                }\n                else {\n                    this.websocket.send(JSON.stringify(message));\n                    this.pending[id] = { cb, index };\n                }\n            }\n        }\n        static init_ImagePipe() {\n            this.define(({ Tuple, String, Number, Any }) => ({\n                init_script: [Any],\n                address: [Tuple(String, Number)],\n                shape: [Tuple(Number, Number, Number, Number)]\n            }));\n        }\n    }\n    exports.ImagePipe = ImagePipe;\n    ImagePipe.__name__ = \"ImagePipe\";\n    ImagePipe.init_ImagePipe();\n}\n","/* src/bokeh/sources/image_data_source.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const column_data_source_1 = require(\"@bokehjs/models/sources/column_data_source\");\n    const string_1 = require(\"@bokehjs/core/util/string\");\n    const image_pipe_1 = require(\"86e287dc15\") /* ./image_pipe */;\n    class ImageDataSource extends column_data_source_1.ColumnDataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.imid = (0, string_1.uuid4)();\n        }\n        initialize() {\n            super.initialize();\n            const execute = () => {\n                if (this.init_script != null)\n                    this.init_script.execute(this);\n            };\n            execute();\n        }\n        channel(c, s = 0, cb) {\n            this.image_source.channel([s, c], (data) => {\n                this.cur_chan = [s, c];\n                if (cb) {\n                    cb(data);\n                }\n                this.data = data.chan;\n            }, this.imid);\n        }\n        refresh(cb) {\n            // supply default index value because the ImagePipe will have no cached\n            // index values for this.imid if there have been no updates yet...\n            this.image_source.refresh((data) => {\n                if (cb) {\n                    cb(data);\n                }\n                this.data = data.chan;\n            }, this.imid, [0, 0]);\n        }\n        static init_ImageDataSource() {\n            this.define(({ Tuple, Number, Ref, Any }) => ({\n                init_script: [Any],\n                image_source: [Ref(image_pipe_1.ImagePipe)],\n                num_chans: [Tuple(Number, Number)],\n                cur_chan: [Tuple(Number, Number)],\n            }));\n        }\n    }\n    exports.ImageDataSource = ImageDataSource;\n    ImageDataSource.__name__ = \"ImageDataSource\";\n    ImageDataSource.init_ImageDataSource();\n}\n","/* src/bokeh/sources/spectra_data_source.js */ function _(require, module, exports, __esModule, __esExport) {\n    __esModule();\n    const column_data_source_1 = require(\"@bokehjs/models/sources/column_data_source\");\n    const string_1 = require(\"@bokehjs/core/util/string\");\n    const image_pipe_1 = require(\"86e287dc15\") /* ./image_pipe */;\n    class SpectraDataSource extends column_data_source_1.ColumnDataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.imid = (0, string_1.uuid4)();\n            console.log('spectra data source id:', this.imid);\n        }\n        initialize() {\n            super.initialize();\n        }\n        spectra(r, d, s = 0) {\n            this.image_source.spectra([r, d, s], (data) => this.data = data.spectrum, this.imid);\n        }\n        refresh() {\n            // supply default index value because the ImagePipe will have no cached\n            // index values for this.imid if there have been no updates yet...\n            this.image_source.refresh((data) => this.data = data.spectrum, this.imid, [0, 0, 0]);\n        }\n        static init_SpectraDataSource() {\n            this.define(({ Ref }) => ({\n                image_source: [Ref(image_pipe_1.ImagePipe)],\n            }));\n        }\n    }\n    exports.SpectraDataSource = SpectraDataSource;\n    SpectraDataSource.__name__ = \"SpectraDataSource\";\n    SpectraDataSource.init_SpectraDataSource();\n}\n"]}